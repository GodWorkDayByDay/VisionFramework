///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 10.0
///////////////////////////////////////////////////////////////////////////////



#include "HalconCpp.h"



using namespace Halcon;

// Default exception handler 
void CPPExpDefaultExceptionHandler(const Halcon::HException& except)
{
  throw except;
}

// Procedure declarations 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.
void dev_update_off ();
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.
void dev_update_on ();
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message.
void disp_message (Halcon::HTuple WindowHandle, Halcon::HTuple String, Halcon::HTuple CoordSystem, 
    Halcon::HTuple Row, Halcon::HTuple Column, Halcon::HTuple Color, Halcon::HTuple Box);
// Chapter: File
// Short Description: Get all image files under the given path
void list_image_files (Halcon::HTuple ImageDirectory, Halcon::HTuple Extensions, 
    Halcon::HTuple Options, Halcon::HTuple *ImageFiles);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS
void set_display_font (Halcon::HTuple WindowHandle, Halcon::HTuple Size, Halcon::HTuple Font, 
    Halcon::HTuple Bold, Halcon::HTuple Slant);
// Local procedures 
void do_inspect2 (Halcon::Hobject Image, Halcon::Hobject *Report, Halcon::HTuple WorkDirectory, 
    Halcon::HTuple WindowRow, Halcon::HTuple WindowColumn, Halcon::HTuple *Result);
void grab_image_from_file (Halcon::Hobject *Image, Halcon::HTuple FileName);
void grab_image_from_camera (Halcon::Hobject *Image, Halcon::HTuple AcqHandle);
void connect_to_camera (Halcon::HTuple *AcqHandle);
void disconnect_from_camera (Halcon::HTuple AcqHandle);
void region_features (Halcon::Hobject Region, Halcon::HTuple Features, Halcon::HTuple *Value);
void extract_edge (Halcon::Hobject Image, Halcon::Hobject ROI1, Halcon::Hobject ROI2, 
    Halcon::Hobject *Region, Halcon::Hobject *Points, Halcon::HTuple Configure, Halcon::HTuple Sort, 
    Halcon::HTuple Direction, Halcon::HTuple *RowBegin, Halcon::HTuple *ColBegin, 
    Halcon::HTuple *RowEnd, Halcon::HTuple *ColEnd);
void extract_pole (Halcon::Hobject Image, Halcon::Hobject ROI, Halcon::Hobject *Region, 
    Halcon::HTuple Configure, Halcon::HTuple *LeftTop, Halcon::HTuple *LeftBottom, 
    Halcon::HTuple *RightTop, Halcon::HTuple *RightBottom, Halcon::HTuple *Row, Halcon::HTuple *Column, 
    Halcon::HTuple *Phi);
void gen_points (Halcon::Hobject *Region, Halcon::HTuple Row, Halcon::HTuple Column, 
    Halcon::HTuple Length);
void OffsetSlove (Halcon::HTuple x1, Halcon::HTuple y1, Halcon::HTuple x2, Halcon::HTuple y2, 
    Halcon::HTuple xx, Halcon::HTuple xy, Halcon::HTuple yx, Halcon::HTuple yy, Halcon::HTuple *Result, 
    Halcon::HTuple *x, Halcon::HTuple *y);
void do_inspect1 (Halcon::Hobject Image, Halcon::Hobject *Report, Halcon::HTuple WorkDirectory, 
    Halcon::HTuple WindowRow, Halcon::HTuple WindowColumn, Halcon::HTuple *Result);
void ClassifyColor (Halcon::Hobject Image, Halcon::HTuple *Kind);

// Procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.
void dev_update_off ()
{
  using namespace Halcon;
  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'.
void dev_update_on ()
{
  using namespace Halcon;
  //This procedure sets different update settings to 'on'.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message.
void disp_message (Halcon::HTuple WindowHandle, Halcon::HTuple String, Halcon::HTuple CoordSystem, 
    Halcon::HTuple Row, Halcon::HTuple Column, Halcon::HTuple Color, Halcon::HTuple Box)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  Red, Green, Blue, Row1Part, Column1Part;
  HTuple  Row2Part, Column2Part, RowWin, ColumnWin, WidthWin;
  HTuple  HeightWin, MaxAscent, MaxDescent, MaxWidth, MaxHeight;
  HTuple  R1, C1, FactorRow, FactorColumn, Width, Index, Ascent;
  HTuple  Descent, W, H, FrameHeight, FrameWidth, R2, C2;
  HTuple  DrawMode, Exception, CurrentColor;


  // Install default exception handler 
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If set to 'true', the text is written within a white box.
  //
  //prepare window
  get_rgb(WindowHandle, &Red, &Green, &Blue);
  get_part(WindowHandle, &Row1Part, &Column1Part, &Row2Part, &Column2Part);
  get_window_extents(WindowHandle, &RowWin, &ColumnWin, &WidthWin, &HeightWin);
  set_part(WindowHandle, 0, 0, HeightWin-1, WidthWin-1);
  //
  //default settings
  if (0 != (Row==-1))
  {
    Row = 12;
  }
  if (0 != (Column==-1))
  {
    Column = 12;
  }
  if (0 != (Color==HTuple()))
  {
    Color = "";
  }
  //
  String = ((""+String)+"").Split("\n");
  //
  //Estimate extentions of text depending on font size.
  get_font_extents(WindowHandle, &MaxAscent, &MaxDescent, &MaxWidth, &MaxHeight);
  if (0 != (CoordSystem==HTuple("window")))
  {
    R1 = Row;
    C1 = Column;
  }
  else
  {
    //transform image to window coordinates
    FactorRow = (1.0*HeightWin)/((Row2Part-Row1Part)+1);
    FactorColumn = (1.0*WidthWin)/((Column2Part-Column1Part)+1);
    R1 = ((Row-Row1Part)+0.5)*FactorRow;
    C1 = ((Column-Column1Part)+0.5)*FactorColumn;
  }
  //
  //display text box depending on text size
  if (0 != (Box==HTuple("true")))
  {
    //calculate box extents
    String = (" "+String)+" ";
    Width = HTuple();
    for (Index=0; Index<=(String.Num())-1; Index+=1)
    {
      get_string_extents(WindowHandle, HTuple(String[Index]), &Ascent, &Descent, 
          &W, &H);
      Width.Append(W);
    }
    FrameHeight = MaxHeight*(String.Num());
    FrameWidth = (HTuple(0).Concat(Width)).Max();
    R2 = R1+FrameHeight;
    C2 = C1+FrameWidth;
    //display rectangles
    get_draw(WindowHandle, &DrawMode);
    set_draw(WindowHandle, "fill");
    set_color(WindowHandle, "light gray");
    disp_rectangle1(WindowHandle, R1+3, C1+3, R2+3, C2+3);
    set_color(WindowHandle, "white");
    disp_rectangle1(WindowHandle, R1, C1, R2, C2);
    set_draw(WindowHandle, DrawMode);
  }
  else if (0 != (Box!=HTuple("false")))
  {
    Exception = "Wrong value of control parameter Box";
    throw HException(Exception);
  }
  //Write text.
  for (Index=0; Index<=(String.Num())-1; Index+=1)
  {
    CurrentColor = Color[Index%(Color.Num())];
    if (0 != (HTuple(CurrentColor!=HTuple("")).And(CurrentColor!=HTuple("auto"))))
    {
      set_color(WindowHandle, CurrentColor);
    }
    else
    {
      set_rgb(WindowHandle, Red, Green, Blue);
    }
    Row = R1+(MaxHeight*Index);
    set_tposition(WindowHandle, Row, C1);
    write_string(WindowHandle, HTuple(String[Index]));
  }
  //reset changed window settings
  set_rgb(WindowHandle, Red, Green, Blue);
  set_part(WindowHandle, Row1Part, Column1Part, Row2Part, Column2Part);
  return;
}

// Chapter: File
// Short Description: Get all image files under the given path
void list_image_files (Halcon::HTuple ImageDirectory, Halcon::HTuple Extensions, 
    Halcon::HTuple Options, Halcon::HTuple *ImageFiles)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  HalconImages, OS, Directories, Index;
  HTuple  FileExists, AllFiles, i, Selection;

  //This procedure returns all files in a given directory
  //with one of the suffixes specified in Extensions.
  //
  //input parameters:
  //ImageDirectory: as the name says
  //   If a tuple of directories is given, only the images in the first
  //   existing directory are returned.
  //   If a local directory is not found, the directory is searched
  //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
  //   %HALCONROOT%/images is used instead.
  //Extensions: A string tuple containing the extensions to be found
  //   e.g. ['png','tif',jpg'] or others
  //If Extensions is set to 'default' or the empty string '',
  //   all image suffixes supported by HALCON are used.
  //Options: as in the operator list_files, except that the 'files'
  //   option is always used. Note that the 'directories' option
  //   has no effect but increases runtime, because only files are
  //   returned.
  //
  //output parameter:
  //ImageFiles: A tuple of all found image file names
  //
  if (0 != (HTuple(HTuple(Extensions==HTuple()).Or(Extensions==HTuple(""))).Or(Extensions==HTuple("default"))))
  {
    Extensions.Reset();
    Extensions[0] = "ima";
    Extensions[1] = "bmp";
    Extensions[2] = "jpg";
    Extensions[3] = "png";
    Extensions[4] = "tiff";
    Extensions[5] = "tif";
    Extensions[6] = "gif";
    Extensions[7] = "jpeg";
    Extensions[8] = "pcx";
    Extensions[9] = "pgm";
    Extensions[10] = "ppm";
    Extensions[11] = "pbm";
    Extensions[12] = "xwd";
    Extensions[13] = "pnm";
  }
  if (0 != (ImageDirectory==HTuple("")))
  {
    ImageDirectory = ".";
  }
  get_system("image_dir", &HalconImages);
  get_system("operating_system", &OS);
  if (0 != ((OS.Substring(0,2))==HTuple("Win")))
  {
    HalconImages = HalconImages.Split(";");
  }
  else
  {
    HalconImages = HalconImages.Split(":");
  }
  Directories.Reset();
  Directories.Append(ImageDirectory);
  Directories.Append((HalconImages+"/")+ImageDirectory);
  (*ImageFiles) = HTuple();
  for (Index=0; Index<=(Directories.Num())-1; Index+=1)
  {
    file_exists(HTuple(Directories[Index]), &FileExists);
    if (0 != FileExists)
    {
      list_files(HTuple(Directories[Index]), HTuple("files").Concat(Options), &AllFiles);
      (*ImageFiles) = HTuple();
      for (i=0; i<=(Extensions.Num())-1; i+=1)
      {
        tuple_regexp_select(AllFiles, ((".*"+HTuple(Extensions[i]))+"$").Concat("ignore_case"), 
            &Selection);
        (*ImageFiles).Append(Selection);
      }
      tuple_regexp_replace((*ImageFiles), (HTuple("\\\\").Append("replace_all")), 
          "/", &(*ImageFiles));
      tuple_regexp_replace((*ImageFiles), (HTuple("//").Append("replace_all")), "/", 
          &(*ImageFiles));
      return;
    }
  }
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS
void set_display_font (Halcon::HTuple WindowHandle, Halcon::HTuple Size, Halcon::HTuple Font, 
    Halcon::HTuple Bold, Halcon::HTuple Slant)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  OS, Exception, AllowedFontSizes, Distances;
  HTuple  Indices;


  // Install default exception handler 
  HException::InstallHHandler(&CPPExpDefaultExceptionHandler);

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  get_system("operating_system", &OS);
  if (0 != (HTuple(Size==HTuple()).Or(Size==-1)))
  {
    Size = 16;
  }
  if (0 != ((OS.Substring(0,2))==HTuple("Win")))
  {
    //set font on Windows systems
    if (0 != (HTuple(HTuple(Font==HTuple("mono")).Or(Font==HTuple("Courier"))).Or(Font==HTuple("courier"))))
    {
      Font = "Courier New";
    }
    else if (0 != (Font==HTuple("sans")))
    {
      Font = "Arial";
    }
    else if (0 != (Font==HTuple("serif")))
    {
      Font = "Times New Roman";
    }
    if (0 != (Bold==HTuple("true")))
    {
      Bold = 1;
    }
    else if (0 != (Bold==HTuple("false")))
    {
      Bold = 0;
    }
    else
    {
      Exception = "Wrong value of control parameter Bold";
      throw HException(Exception);
    }
    if (0 != (Slant==HTuple("true")))
    {
      Slant = 1;
    }
    else if (0 != (Slant==HTuple("false")))
    {
      Slant = 0;
    }
    else
    {
      Exception = "Wrong value of control parameter Slant";
      throw HException(Exception);
    }
    try
    {
      set_font(WindowHandle, ((((((("-"+Font)+"-")+Size)+"-*-")+Slant)+"-*-*-")+Bold)+"-");
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&Exception);
      throw HException(Exception);
    }
  }
  else
  {
    //set font for UNIX systems
    Size = Size*1.25;
    AllowedFontSizes.Reset();
    AllowedFontSizes[0] = 11;
    AllowedFontSizes[1] = 14;
    AllowedFontSizes[2] = 17;
    AllowedFontSizes[3] = 20;
    AllowedFontSizes[4] = 25;
    AllowedFontSizes[5] = 34;
    if (0 != ((AllowedFontSizes.Find(Size))==-1))
    {
      Distances = (AllowedFontSizes-Size).Abs();
      tuple_sort_index(Distances, &Indices);
      Size = AllowedFontSizes[HTuple(Indices[0])];
    }
    if (0 != (HTuple(Font==HTuple("mono")).Or(Font==HTuple("Courier"))))
    {
      Font = "courier";
    }
    else if (0 != (Font==HTuple("sans")))
    {
      Font = "helvetica";
    }
    else if (0 != (Font==HTuple("serif")))
    {
      Font = "times";
    }
    if (0 != (Bold==HTuple("true")))
    {
      Bold = "bold";
    }
    else if (0 != (Bold==HTuple("false")))
    {
      Bold = "medium";
    }
    else
    {
      Exception = "Wrong value of control parameter Bold";
      throw HException(Exception);
    }
    if (0 != (Slant==HTuple("true")))
    {
      if (0 != (Font==HTuple("times")))
      {
        Slant = "i";
      }
      else
      {
        Slant = "o";
      }
    }
    else if (0 != (Slant==HTuple("false")))
    {
      Slant = "r";
    }
    else
    {
      Exception = "Wrong value of control parameter Slant";
      throw HException(Exception);
    }
    try
    {
      set_font(WindowHandle, ((((((("-adobe-"+Font)+"-")+Bold)+"-")+Slant)+"-normal-*-")+Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&Exception);
      throw HException(Exception);
    }
  }
  return;
}

// Local procedures 
void do_inspect2 (Halcon::Hobject Image, Halcon::Hobject *Report, Halcon::HTuple WorkDirectory, 
    Halcon::HTuple WindowRow, Halcon::HTuple WindowColumn, Halcon::HTuple *Result)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  EmptyRegion, GrayImage, R, G, B, H, S;
  Hobject  V, RImageMean, LEDRegion, LEDConnectedRegions, LEDSelectedRegions;
  Hobject  LED;


  // Local control variables 
  HTuple  train_mode, debugging, programming, Width;
  HTuple  Height, WindowHandle, VisionResult, LEDNumber;


  train_mode = 0;
  debugging = 1;
  programming = 0;

  if (0 != (programming.Not()))
  {
    // dev_update_off(...); only in hdevelop
  }
  else
  {
    // dev_update_on(...); only in hdevelop
  }

  get_image_size(Image, &Width, &Height);
  set_window_attr("background_color","black");
  open_window(0,0,Width,Height,0,"","",&WindowHandle);
  HDevWindowStack::Push(WindowHandle);

  //
  //results
  //
  gen_empty_region(&EmptyRegion);
  VisionResult = 1;

  //
  //grab image
  //
  if (HDevWindowStack::IsOpen())
    set_draw(HDevWindowStack::GetActive(),"fill");
  //
  //pre process
  //
  rgb1_to_gray(Image, &GrayImage);
  decompose3(Image, &R, &G, &B);
  trans_from_rgb(R, G, B, &H, &S, &V, "hsv");


  //do inspect

  //red led
  mean_image(R, &RImageMean, 3, 3);
  threshold(RImageMean, &LEDRegion, 200, 255);
  connection(LEDRegion, &LEDConnectedRegions);
  select_shape(LEDConnectedRegions, &LEDSelectedRegions, (HTuple("rectangularity").Append("area")), 
      "and", (HTuple(0.8).Append(1200)), (HTuple(1).Append(4000)));
  count_obj(LEDSelectedRegions, &LEDNumber);

  tuple_and(VisionResult, LEDNumber, &VisionResult);

  if (0 != (VisionResult.Not()))
  {
    //yellow led

  }

  //
  //calculation results
  //
  union1(LEDSelectedRegions, &LED);

  if (HDevWindowStack::IsOpen())
    disp_obj(Image, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    set_line_width(HDevWindowStack::GetActive(),3);
  if (HDevWindowStack::IsOpen())
    set_color(HDevWindowStack::GetActive(),"red");
  if (HDevWindowStack::IsOpen())
    disp_obj(LED, HDevWindowStack::GetActive());


  set_display_font(WindowHandle, 30, "mono", "true", "false");
  if (0 != (VisionResult==0))
  {
    disp_message(WindowHandle, "NG", "window", 20, 20, "red", "true");
  }
  else
  {
    disp_message(WindowHandle, "OK", "window", 20, 20, "green", "true");
  }

  dump_window_image(&(*Report), WindowHandle);
  if (HDevWindowStack::IsOpen())
    close_window(HDevWindowStack::Pop());

  (*Result) = VisionResult;


}

void grab_image_from_file (Halcon::Hobject *Image, Halcon::HTuple FileName)
{
  using namespace Halcon;

  read_image(&(*Image), FileName);

  return;

}

void grab_image_from_camera (Halcon::Hobject *Image, Halcon::HTuple AcqHandle)
{
  using namespace Halcon;
  grab_image(&(*Image), AcqHandle);
  return;

}

void connect_to_camera (Halcon::HTuple *AcqHandle)
{
  using namespace Halcon;
  //Code generated by Image Acquisition 01
  //Code generated by Image Acquisition 01
  open_framegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "rgb", -1, "false", 
      "default", "USB2.0 PC CAMERA", 0, -1, &(*AcqHandle));
  grab_image_start((*AcqHandle), -1);

  return;

}

void disconnect_from_camera (Halcon::HTuple AcqHandle)
{
  using namespace Halcon;
  close_framegrabber(AcqHandle);
  return;

}

void region_features (Halcon::Hobject Region, Halcon::HTuple Features, Halcon::HTuple *Value)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  area, row, column, row1, column1, row2;
  HTuple  column2, ra, rb, phi, anisometry, bulkiness, struct_factor;
  HTuple  row3, column3, row4, column4, dist_mean, dist_deviation;
  HTuple  _roundness, num_sides, connect_num, holes_num, row5;
  HTuple  column5, rect2_phi, rect2_len1, rect2_len2, moments_m11;
  HTuple  moments_m20, moments_m02, moments_ia, moments_ib;
  HTuple  moments_m11_invar, moments_m20_invar, moments_m02_invar;
  HTuple  moments_phi1, moments_phi2, moments_m21, moments_m12;
  HTuple  moments_m03, moments_m30, moments_m21_invar, moments_m12_invar;
  HTuple  moments_m03_invar, moments_m30_invar, moments_i1;
  HTuple  moments_i2, moments_i3, moments_i4, moments_psi1;
  HTuple  moments_psi2, moments_psi3, moments_psi4, itr, Circularity;
  HTuple  Compactness, ContLength, Convexity, Rectangularity;
  HTuple  Row, Column, Radius, Area, Row1, Column1, Row2;
  HTuple  Column2, Diameter, Phi, EulerNumber;


  tuple_gen_const(Features.Num(), 0, &(*Value));
  area_center(Region, &area, &row, &column);
  smallest_rectangle1(Region, &row1, &column1, &row2, &column2);
  elliptic_axis(Region, &ra, &rb, &phi);
  eccentricity(Region, &anisometry, &bulkiness, &struct_factor);
  inner_rectangle1(Region, &row3, &column3, &row4, &column4);
  roundness(Region, &dist_mean, &dist_deviation, &_roundness, &num_sides);
  connect_and_holes(Region, &connect_num, &holes_num);
  smallest_rectangle2(Region, &row5, &column5, &rect2_phi, &rect2_len1, &rect2_len2);
  moments_region_2nd(Region, &moments_m11, &moments_m20, &moments_m02, &moments_ia, 
      &moments_ib);
  moments_region_2nd_invar(Region, &moments_m11_invar, &moments_m20_invar, &moments_m02_invar);
  moments_region_2nd_rel_invar(Region, &moments_phi1, &moments_phi2);
  moments_region_3rd(Region, &moments_m21, &moments_m12, &moments_m03, &moments_m30);
  moments_region_3rd_invar(Region, &moments_m21_invar, &moments_m12_invar, &moments_m03_invar, 
      &moments_m30_invar);
  moments_region_central(Region, &moments_i1, &moments_i2, &moments_i3, &moments_i4);
  moments_region_central_invar(Region, &moments_psi1, &moments_psi2, &moments_psi3, 
      &moments_psi4);

  for (itr=0; itr<=(Features.Num())-1; itr+=1)
  {
    if (0 != (HTuple(Features[itr])==HTuple("area")))
    {
      (*Value)[itr] = area;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("row")))
    {
      (*Value)[itr] = row;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("column")))
    {
      (*Value)[itr] = column;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("width")))
    {
      (*Value)[itr] = (column2-column1)+1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("height")))
    {
      (*Value)[itr] = (row2-row1)+1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("row1")))
    {
      (*Value)[itr] = row1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("column1")))
    {
      (*Value)[itr] = column1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("row2")))
    {
      (*Value)[itr] = row2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("column2")))
    {
      (*Value)[itr] = column2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("circularity")))
    {
      circularity(Region, &Circularity);
      (*Value)[itr] = Circularity;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("compactness")))
    {
      compactness(Region, &Compactness);
      (*Value)[itr] = Compactness;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("contlength")))
    {
      contlength(Region, &ContLength);
      (*Value)[itr] = ContLength;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("convexity")))
    {
      convexity(Region, &Convexity);
      (*Value)[itr] = Convexity;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("rectangularity")))
    {
      rectangularity(Region, &Rectangularity);
      (*Value)[itr] = Rectangularity;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("ra")))
    {
      (*Value)[itr] = ra;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("rb")))
    {
      (*Value)[itr] = rb;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("phi")))
    {
      (*Value)[itr] = phi;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("anisometry")))
    {
      (*Value)[itr] = anisometry;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("bulkiness")))
    {
      (*Value)[itr] = bulkiness;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("struct_factor")))
    {
      (*Value)[itr] = struct_factor;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("outer_radius")))
    {
      smallest_circle(Region, &Row, &Column, &Radius);
      (*Value)[itr] = Radius;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("inner_radius")))
    {
      inner_circle(Region, &Row, &Column, &Radius);
      (*Value)[itr] = Radius;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("inner_width")))
    {
      (*Value)[itr] = (column4-column3)+1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("inner_height")))
    {
      (*Value)[itr] = (row4-row3)+1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("dist_mean")))
    {
      (*Value)[itr] = dist_mean;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("dist_deviation")))
    {
      (*Value)[itr] = dist_deviation;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("roundness")))
    {
      (*Value)[itr] = _roundness;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("num_sides")))
    {
      (*Value)[itr] = num_sides;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("connect_num")))
    {
      (*Value)[itr] = connect_num;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("holes_num")))
    {
      (*Value)[itr] = holes_num;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("area_holes")))
    {
      area_holes(Region, &Area);
      (*Value)[itr] = Area;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("max_diameter")))
    {
      diameter_region(Region, &Row1, &Column1, &Row2, &Column2, &Diameter);
      (*Value)[itr] = Diameter;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("orientation")))
    {
      orientation_region(Region, &Phi);
      (*Value)[itr] = Phi;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("euler_number")))
    {
      euler_number(Region, &EulerNumber);
      (*Value)[itr] = EulerNumber;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("rect2_phi")))
    {
      (*Value)[itr] = rect2_phi;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("rect2_len1")))
    {
      (*Value)[itr] = rect2_len1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("rect2_len2")))
    {
      (*Value)[itr] = rect2_len2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m11")))
    {
      (*Value)[itr] = moments_m11;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m20")))
    {
      (*Value)[itr] = moments_m20;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m02")))
    {
      (*Value)[itr] = moments_m02;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_ia")))
    {
      (*Value)[itr] = moments_ia;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_ib")))
    {
      (*Value)[itr] = moments_ib;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m11_invar")))
    {
      (*Value)[itr] = moments_m11_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m20_invar")))
    {
      (*Value)[itr] = moments_m20_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m02_invar")))
    {
      (*Value)[itr] = moments_m02_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_phi1")))
    {
      (*Value)[itr] = moments_phi1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_phi2")))
    {
      (*Value)[itr] = moments_phi2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m21")))
    {
      (*Value)[itr] = moments_m21;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m12")))
    {
      (*Value)[itr] = moments_m12;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m03")))
    {
      (*Value)[itr] = moments_m03;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m30")))
    {
      (*Value)[itr] = moments_m30;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m21_invar")))
    {
      (*Value)[itr] = moments_m21_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m12_invar")))
    {
      (*Value)[itr] = moments_m12_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m03_invar")))
    {
      (*Value)[itr] = moments_m03_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_m30_invar")))
    {
      (*Value)[itr] = moments_m30_invar;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_i1")))
    {
      (*Value)[itr] = moments_i1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_i2")))
    {
      (*Value)[itr] = moments_i2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_i3")))
    {
      (*Value)[itr] = moments_i3;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_i4")))
    {
      (*Value)[itr] = moments_i4;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_psi1")))
    {
      (*Value)[itr] = moments_psi1;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_psi2")))
    {
      (*Value)[itr] = moments_psi2;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_psi3")))
    {
      (*Value)[itr] = moments_psi3;
      continue;
    }

    if (0 != (HTuple(Features[itr])==HTuple("moments_psi4")))
    {
      (*Value)[itr] = moments_psi4;
      continue;
    }
  }

  return;
}

void extract_edge (Halcon::Hobject Image, Halcon::Hobject ROI1, Halcon::Hobject ROI2, 
    Halcon::Hobject *Region, Halcon::Hobject *Points, Halcon::HTuple Configure, Halcon::HTuple Sort, 
    Halcon::HTuple Direction, Halcon::HTuple *RowBegin, Halcon::HTuple *ColBegin, 
    Halcon::HTuple *RowEnd, Halcon::HTuple *ColEnd)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  ImageReduced, Edges, SortedContours;
  Hobject  ObjectSelected, RegionTemp;


  // Local control variables 
  HTuple  Number, Nr, Nc, Dist, Row1, Column1, Row2;
  HTuple  Column2;

  gen_empty_region(&(*Points));
  union2(ROI1, ROI2, &(*Region));

  //
  //edge1
  //
  reduce_domain(Image, ROI1, &ImageReduced);
  edges_sub_pix(ImageReduced, &Edges, "lanser2", 0.5, 20, 40);
  count_obj(Edges, &Number);

  if (0 != (Number==0))
  {
    return;
  }

  sort_contours_xld(Edges, &SortedContours, "upper_left", Direction, Sort);
  select_obj(SortedContours, &ObjectSelected, 1);
  fit_line_contour_xld(ObjectSelected, "tukey", -1, 0, 5, 2, &(*RowBegin), &(*ColBegin), 
      &(*RowEnd), &(*ColEnd), &Nr, &Nc, &Dist);
  difference((*Region), ROI1, &(*Region));
  Row1 = ((*RowBegin)+(*RowEnd))/2;
  Column1 = ((*ColBegin)+(*ColEnd))/2;
  gen_points(&RegionTemp, Row1, Column1, 10);
  union2((*Points), RegionTemp, &(*Points));

  //
  //edge2
  //
  reduce_domain(Image, ROI2, &ImageReduced);
  edges_sub_pix(ImageReduced, &Edges, "lanser2", 0.5, 20, 40);
  count_obj(Edges, &Number);

  if (0 != (Number==0))
  {
    return;
  }

  sort_contours_xld(Edges, &SortedContours, "upper_left", Direction, Sort);
  select_obj(SortedContours, &ObjectSelected, 1);
  fit_line_contour_xld(ObjectSelected, "tukey", -1, 0, 5, 2, &(*RowBegin), &(*ColBegin), 
      &(*RowEnd), &(*ColEnd), &Nr, &Nc, &Dist);
  difference((*Region), ROI2, &(*Region));
  Row2 = ((*RowBegin)+(*RowEnd))/2;
  Column2 = ((*ColBegin)+(*ColEnd))/2;
  gen_points(&RegionTemp, Row2, Column2, 10);
  union2((*Points), RegionTemp, &(*Points));

  //
  //result
  //
  (*RowBegin) = Row1;
  (*ColBegin) = Column1;
  (*RowEnd) = Row2;
  (*ColEnd) = Column2;
  return;

}

void extract_pole (Halcon::Hobject Image, Halcon::Hobject ROI, Halcon::Hobject *Region, 
    Halcon::HTuple Configure, Halcon::HTuple *LeftTop, Halcon::HTuple *LeftBottom, 
    Halcon::HTuple *RightTop, Halcon::HTuple *RightBottom, Halcon::HTuple *Row, Halcon::HTuple *Column, 
    Halcon::HTuple *Phi)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  ImageReduced, SelectedRegions, Contours;


  // Local control variables 
  HTuple  Number, Length1, Length2, PointOrder;
  HTuple  Cos, Sin;


  reduce_domain(Image, ROI, &ImageReduced);
  threshold(ImageReduced, &(*Region), 0, 200);
  select_shape((*Region), &SelectedRegions, "area", "and", 23000, 35000);
  count_obj(SelectedRegions, &Number);

  if (0 != (Number!=1))
  {
    union2((*Region), ROI, &(*Region));
    return;
  }

  gen_contour_region_xld(SelectedRegions, &Contours, "border");
  fit_rectangle2_contour_xld(Contours, "regression", -1, 0, 0, 3, 2, &(*Row), &(*Column), 
      &(*Phi), &Length1, &Length2, &PointOrder);
  gen_empty_region(&(*Region));

  tuple_cos((*Phi), &Cos);
  tuple_sin((*Phi), &Sin);

  (*LeftBottom).Reset();
  (*LeftBottom).Append(((*Row)+(Length1*Sin))+(Length2*Cos));
  (*LeftBottom).Append(((*Column)-(Length1*Cos))+(Length2*Sin));
  (*RightBottom).Reset();
  (*RightBottom).Append(((*Row)-(Length1*Sin))+(Length2*Cos));
  (*RightBottom).Append(((*Column)+(Length1*Cos))+(Length2*Sin));
  (*LeftTop).Reset();
  (*LeftTop).Append(((*Row)+(Length1*Sin))-(Length2*Cos));
  (*LeftTop).Append(((*Column)-(Length1*Cos))-(Length2*Sin));
  (*RightTop).Reset();
  (*RightTop).Append(((*Row)-(Length1*Sin))-(Length2*Cos));
  (*RightTop).Append(((*Column)+(Length1*Cos))-(Length2*Sin));
  return;

}

void gen_points (Halcon::Hobject *Region, Halcon::HTuple Row, Halcon::HTuple Column, 
    Halcon::HTuple Length)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  RegionLines;


  // Local control variables 
  HTuple  length, itr, line;

  gen_empty_region(&(*Region));

  length = HTuple(Row.Num()).Min2(Column.Num());

  for (itr=0; itr<=length-1; itr+=1)
  {
    line.Reset();
    line.Append(HTuple(Row[itr])+Length);
    line.Append(HTuple(Column[itr])+Length);
    line.Append(HTuple(Row[itr])-Length);
    line.Append(HTuple(Column[itr])-Length);
    gen_region_line(&RegionLines, HTuple(line[0]), HTuple(line[1]), HTuple(line[2]), 
        HTuple(line[3]));
    union2((*Region), RegionLines, &(*Region));

    line.Reset();
    line.Append(HTuple(Row[itr])+Length);
    line.Append(HTuple(Column[itr])-Length);
    line.Append(HTuple(Row[itr])-Length);
    line.Append(HTuple(Column[itr])+Length);
    gen_region_line(&RegionLines, HTuple(line[0]), HTuple(line[1]), HTuple(line[2]), 
        HTuple(line[3]));
    union2((*Region), RegionLines, &(*Region));
  }

  return;

}

void OffsetSlove (Halcon::HTuple x1, Halcon::HTuple y1, Halcon::HTuple x2, Halcon::HTuple y2, 
    Halcon::HTuple xx, Halcon::HTuple xy, Halcon::HTuple yx, Halcon::HTuple yy, Halcon::HTuple *Result, 
    Halcon::HTuple *x, Halcon::HTuple *y)
{
  using namespace Halcon;

  // Local control variables 
  HTuple  _k, _x, _y;

  _k = (xx*yy)-(xy*yx);
  _x = x2-x1;
  _y = y2-y1;

  if (0 != (HTuple(HTuple(_x!=0).Or(_y!=0)).And(_k==0)))
  {
    (*Result) = 0;
  }
  else
  {
    (*Result) = 1;

    if (0 != (_x==0))
    {
      (*x) = 0;
    }
    else
    {
      (*x) = ((_x*yy)-(yx*_y))/_k;
    }

    if (0 != (_y==0))
    {
      (*y) = 0;
    }
    else
    {
      (*y) = ((_y*xx)-(xy*_x))/_k;
    }
  }

  return;

}

void do_inspect1 (Halcon::Hobject Image, Halcon::Hobject *Report, Halcon::HTuple WorkDirectory, 
    Halcon::HTuple WindowRow, Halcon::HTuple WindowColumn, Halcon::HTuple *Result)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  EmptyRegion, RegionGuide, RegionNetLine;
  Hobject  RegionAdapter, RegionResult, Red, Green, Blue, Hue;
  Hobject  Saturation, Value, WholeRegion, ImageMean, NetLineRegion;
  Hobject  NetLineOpening, NetLineConnnection, RegionRemain;
  Hobject  ImageReduced, RegionPossGuide, OpenGuide, CloseGuide;
  Hobject  ConnectedRegions, RegionModelAdapter;


  // Local control variables 
  HTuple  train_mode, debugging, programming, guide_not_found;
  HTuple  netline_not_found, adapter_not_found, length_left;
  HTuple  offset_left, length_right, offset_right, Image_Width;
  HTuple  Image_Height, IsEqual, ModelID, RefPoint, RowRef;
  HTuple  ColumnRef, Row, Column, Angle, Score, HomMat2D;
  HTuple  Width, Height, WindowHandle;


  train_mode = 0;
  debugging = 1;
  programming = 0;

  if (0 != (programming.Not()))
  {
    // dev_update_off(...); only in hdevelop
  }
  else
  {
    // dev_update_on(...); only in hdevelop
  }

  //
  //results
  //
  gen_empty_region(&EmptyRegion);
  gen_empty_region(&RegionGuide);
  gen_empty_region(&RegionNetLine);
  gen_empty_region(&RegionAdapter);
  gen_empty_region(&RegionResult);

  guide_not_found = 0;
  netline_not_found = 0;
  adapter_not_found = 0;

  length_left = HTuple();
  offset_left = HTuple();
  length_right = HTuple();
  offset_right = HTuple();

  //
  //grab image
  //
  //get_image_size (Image, Image_Width, Image_Height)
  //rotate_image (Image, Image, 180, 'constant')

  //
  //pre process
  //
  decompose3(Image, &Red, &Green, &Blue);
  trans_from_rgb(Red, Green, Blue, &Hue, &Saturation, &Value, "hsv");
  threshold(Value, &WholeRegion, 0, 255);
  //
  //NetLine
  //
  mean_image(Saturation, &ImageMean, 13, 13);
  threshold(ImageMean, &NetLineRegion, 100, 255);
  opening_circle(NetLineRegion, &NetLineOpening, 9);
  connection(NetLineOpening, &NetLineConnnection);
  select_shape(NetLineConnnection, &RegionNetLine, "area", "and", 110000, 160000);
  test_equal_region(RegionNetLine, EmptyRegion, &IsEqual);

  if (0 != IsEqual)
  {
    if (0 != debugging)
    {
      // stop(); only in hdevelop
    }
    netline_not_found = 1;
  }
  else
  {
    union2(RegionResult, RegionNetLine, &RegionResult);
    difference(WholeRegion, RegionResult, &RegionRemain);
    reduce_domain(Value, RegionRemain, &ImageReduced);
    netline_not_found = 0;
  }

  //
  //Guide
  //
  threshold(ImageReduced, &RegionPossGuide, 180, 255);
  opening_circle(RegionPossGuide, &OpenGuide, 8);
  closing_circle(OpenGuide, &CloseGuide, 15);
  connection(CloseGuide, &ConnectedRegions);
  select_shape(ConnectedRegions, &RegionGuide, (HTuple("area").Append("rectangularity")), 
      "and", (HTuple(100000).Append(0.8)), (HTuple(999999).Append(1)));
  test_equal_region(RegionGuide, EmptyRegion, &IsEqual);

  if (0 != IsEqual)
  {
    if (0 != debugging)
    {
      // stop(); only in hdevelop
    }
    guide_not_found = 1;
  }
  else
  {
    union2(RegionResult, RegionGuide, &RegionResult);
    difference(WholeRegion, RegionResult, &RegionRemain);
    reduce_domain(Value, RegionRemain, &ImageReduced);
    guide_not_found = 0;
  }

  //
  //adapter
  //
  read_ncc_model("adapter.ncm", &ModelID);
  read_tuple("refpoint.tup", &RefPoint);
  read_region(&RegionModelAdapter, "region.reg");
  RowRef = RefPoint[0];
  ColumnRef = RefPoint[1];

  find_ncc_model(Image, ModelID, -0.39, 0.79, 0.5, 1, 0.5, "true", 0, &Row, &Column, 
      &Angle, &Score);
  if (0 != (Score>0.8))
  {
    vector_angle_to_rigid(RowRef, ColumnRef, 0, Row, Column, Angle, &HomMat2D);
    affine_trans_region(RegionModelAdapter, &RegionAdapter, HomMat2D, "false");
  }
  test_equal_region(RegionAdapter, EmptyRegion, &IsEqual);

  if (0 != IsEqual)
  {
    if (0 != debugging)
    {
      // stop(); only in hdevelop
    }
    adapter_not_found = 1;
  }
  else
  {
    union2(RegionResult, RegionAdapter, &RegionResult);
    difference(WholeRegion, RegionResult, &RegionRemain);
    reduce_domain(Value, RegionRemain, &ImageReduced);
    adapter_not_found = 0;
  }

  //
  //calculation results
  //
  (*Result) = 0;

  if (0 != guide_not_found)
  {
    tuple_bor((*Result), 1, &(*Result));
  }

  if (0 != netline_not_found)
  {
    tuple_bor((*Result), 2, &(*Result));
  }

  if (0 != adapter_not_found)
  {
    tuple_bor((*Result), 4, &(*Result));
  }

  get_image_size(Image, &Width, &Height);
  set_window_attr("background_color","black");
  open_window(WindowRow,WindowColumn,Width,Height,0,"","",&WindowHandle);
  HDevWindowStack::Push(WindowHandle);
  if (HDevWindowStack::IsOpen())
    set_draw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    disp_obj(Image, HDevWindowStack::GetActive());

  if (HDevWindowStack::IsOpen())
    set_line_width(HDevWindowStack::GetActive(),8);
  if (HDevWindowStack::IsOpen())
    set_color(HDevWindowStack::GetActive(),"red");
  if (HDevWindowStack::IsOpen())
    disp_obj(RegionNetLine, HDevWindowStack::GetActive());

  if (HDevWindowStack::IsOpen())
    set_line_width(HDevWindowStack::GetActive(),8);
  if (HDevWindowStack::IsOpen())
    set_color(HDevWindowStack::GetActive(),"slate blue");
  if (HDevWindowStack::IsOpen())
    disp_obj(RegionGuide, HDevWindowStack::GetActive());

  if (HDevWindowStack::IsOpen())
    set_line_width(HDevWindowStack::GetActive(),8);
  if (HDevWindowStack::IsOpen())
    set_color(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    disp_obj(RegionAdapter, HDevWindowStack::GetActive());

  dump_window_image(&(*Report), WindowHandle);
  if (HDevWindowStack::IsOpen())
    close_window(HDevWindowStack::Pop());

  if (0 != ((*Result)!=0))
  {
    if (0 != debugging)
    {
      // stop(); only in hdevelop
    }
  }

}

void ClassifyColor (Halcon::Hobject Image, Halcon::HTuple *Kind)
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  R, G, B, RRegion;


  decompose3(Image, &R, &G, &B);
  threshold(R, &RRegion, 180, 255);

  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{
  using namespace Halcon;

  // Local iconic variables 
  Hobject  Image, Report;


  // Local control variables 
  HTuple  dry_cycle, debugging, programming, AcqHandle;
  HTuple  Result, samples, image_id;

  dry_cycle = 0;
  debugging = 1;
  programming = 1;

  connect_to_camera(&AcqHandle);

  do
  {
    grab_image_from_camera(&Image, AcqHandle);
    if (HDevWindowStack::IsOpen())
      disp_obj(Image, HDevWindowStack::GetActive());
    do_inspect2(Image, &Report, "./PartDetection", 768, 1366, &Result);
    if (HDevWindowStack::IsOpen())
      disp_obj(Report, HDevWindowStack::GetActive());
  }
  while (0 == 0);

  disconnect_from_camera(AcqHandle);
  return;

  list_image_files("./samples", "bmp", HTuple(), &samples);

  for (image_id=0; image_id<=(samples.Num())-1; image_id+=1)
  {

    if (0 != (programming.Not()))
    {
      // dev_update_off(...); only in hdevelop
    }
    else
    {
      // dev_update_on(...); only in hdevelop
    }

    //
    //grab image
    //
    grab_image_from_file(&Image, HTuple(samples[image_id]));
    if (HDevWindowStack::IsOpen())
      disp_obj(Image, HDevWindowStack::GetActive());

    //
    //do inspect
    //
    do_inspect1(Image, &Report, "./PartDetection", 768, 1366, &Result);
    if (HDevWindowStack::IsOpen())
      disp_obj(Report, HDevWindowStack::GetActive());

    //
    //end
    //
    if (0 != dry_cycle)
    {
      break;
    }

    if (0 != (Result!=0))
    {
      // stop(); only in hdevelop
    }
  }

}


#ifndef NO_EXPORT_APP_MAIN
int main(int argc, char *argv[])
{
  using namespace Halcon;
  // Default settings used in HDevelop (can be omitted) 
  set_system("do_low_error","false");
  action();
  return 0;
}
#endif


#endif


